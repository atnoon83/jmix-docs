= Аутентификация

Аутентификация – это процесс проверки личности пользователя или процесса, который взаимодействует с системой. Например, система может аутентифицировать пользователей по их имени и паролю. Для аутентифицированных пользователей система может выполнить xref:authorization.adoc[авторизацию], которая представляет собой проверку разрешений для определенного ресурса.

Jmix напрямую использует {spring-security-doc}/servlet/authentication/index.html[Servlet аутентификацию^] Spring Security, поэтому если вы знакомы с этой платформой, то вы можете легко расширить или переопределить стандартный механизм аутентификации, предоставляемый Jmix "из коробки".

[[current]]
== Текущий пользователь

Чтобы определить, кто в данный момент аутентифицирован, используйте бин `CurrentAuthentication`. Он имеет следующие методы:

* `getUser()` возвращает текущего аутентифицированного пользователя как {spring-security-api}/org/springframework/security/core/userdetails/UserDetails.html[UserDetails^]. Его можно привести к классу xref:users.adoc#entity[пользователя], определенному в проекте.

* `getAuthentication()` возвращает объект {spring-security-api}/org/springframework/security/core/Authentication.html[Authentication^], установленный в текущем потоке выполнения. Его можно использовать, чтобы получить коллекцию https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/GrantedAuthority.html[полномочий^] текущего пользователя. В стандартной реализации безопасности Jmix эта коллекция содержит объекты полномочий для каждой xref:resource-roles.adoc[ресурсной] и xref:row-level-roles.adoc[row-level] роли, назначенной пользователю.

* `getLocale()` и `getTimeZone()` возвращают локаль и часовой пояс текущего пользователя.

* `isSet()` возвращает значение true, если текущий поток выполнения аутентифицирован, то есть содержит информацию о пользователе. Если это не так, методы `getUser()`, `getLocale()` и `getTimeZone()`, описанные выше, выбросят исключение `IllegalStateException`.

Ниже приведен пример получения информации о текущем пользователе:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/screen/auth/AuthTestScreen.java[tags=current-auth]
----

[NOTE]
====
`CurrentAuthentication` – это просто обёртка вокруг {spring-security-api}/org/springframework/security/core/context/SecurityContextHolder.html[SecurityContextHolder^], поэтому он полностью совместим со всеми механизмами Spring Security.

Например, вы можете использовать `DelegatingSecurityContextRunnable` для передачи контекста аутентификации в новые потоки как описано в {spring-security-doc}/servlet/integrations/concurrency.html[документации Spring Security^].
====

[[client]]
== Аутентификация клиента

У бэкенда приложения Jmix могут быть разные клиенты, например, UI, GraphQL, или REST API. Каждый клиент имеет свой собственный стандартный механизм аутентификации, например:

* xref:ui:screens/root-screens.adoc#login-screen[Окно входа] UI
* xref:rest:security/authentication.adoc[Аутентификация] REST

[[custom-password-validation]]
=== Собственная валидация паролей

Чтобы реализовать собственную валидацию паролей в приложении, достаточно создать бин (или несколько бинов), реализующий интерфейс `PasswordValidator`. Например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/security/MyPasswordValidator.java[]
----

Все валидаторы будут автоматически использованы в диалоге действия ChangePassword.

Для добавления кастомной валидации в экран редактирования сущности User, используйте бин-помощник `PasswordValidation`:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/screen/user/UserEdit.java[tags=password-validation]
----

[[brute-force-protection]]
=== Защита от взлома методом перебора

В фреймворке есть механизм защиты от взлома паролей методом перебора, которая обеспечивается свойством приложения <<jmix.security.bruteforceprotection.enabled,jmix.security.bruteforceprotection.enabled>>. Если она включена, комбинация логина пользователя и IP-адреса блокируется на определенный промежуток времени в случае нескольких неудачных попыток входа в систему. Максимальное количество попыток определяется свойством приложения <<jmix.security.bruteforceprotection.max-login-attempts-number,jmix.security.bruteforceprotection.max-login-attempts-number>>. Интервал блокировки в секундах определяется свойством приложения <<jmix.security.bruteforceprotection.block-interval,jmix.security.bruteforceprotection.block-interval>>.

[[jmix.security.bruteforceprotection.enabled]]
* `jmix.security.bruteforceprotection.enabled`
+
Включает механизм защиты от взлома пароля методом перебора. Значение по умолчанию: `false`.

[[jmix.security.bruteforceprotection.block-interval]]
* `jmix.security.bruteforceprotection.block-interval`
+
Определяет интервал блокировки в секундах после превышения максимального количества неудачных попыток входа в систему, если включено свойство <<jmix.security.bruteforceprotection.enabled,jmix.security.bruteforceprotection.enabled>>. Значение по умолчанию: `60 seconds`.

[[jmix.security.bruteforceprotection.max-login-attempts-number]]
* `jmix.security.bruteforceprotection.max-login-attempts-number`
+
Определяет максимальное количество неудачных попыток входа в систему для комбинации логина пользователя и IP-адреса, если включено свойство <<jmix.security.bruteforceprotection.enabled,jmix.security.bruteforceprotection.enabled>>. Значение по умолчанию: `5`.

[[session-attributes]]
=== Атрибуты сессии

Если вам необходимо использовать некоторые значения в нескольких запросах от одного и того же подключенного пользователя, используйте бин `SessionData`. В нем есть методы для чтения и записи именованных значений, хранящихся в текущей сессии пользователя.

Бин `SessionData` можно инжектировать напрямую в экраны UI:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/screen/customer/CustomerBrowse.java[tags=session-data]
----

В singleton-бине используйте `SessionData` через `org.springframework.beans.factory.ObjectProvider`:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/service/CustomerService.java[tags=session-data]
----

TIP: Атрибуты сессии также можно использовать в xref:data-access:jpql-extensions.adoc#session-and-user-attributes[запросах JPQL].

[[system]]
== Системная аутентификация

Поток выполнения может быть не аутентифицирован, если был запущен внутренним планировщиком или обрабатывает запрос из JMX-интерфейса. Однако обычно бизнес-логике или коду доступа к данным для журналирования или авторизации требуется информация о том, кто в данный момент работает с системой.

Чтобы временно связать текущий поток выполнения с пользователем, используйте бин `SystemAuthenticator`. Он имеет следующие методы:

* `withSystem()` - принимает lambda-выражение и выполняет его от имени xref:users.adoc#built-in[системного] пользователя.

* `withUser()` - принимает имя обычного пользователя приложения и lambda-выражение и выполняет его от имени данного пользователя с соответствующими разрешениями.

Ниже приведен пример аутентификации операции MBean:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/mbean/SettingsManagementFacade.java[tags=system-authenticator;current-authentication;system-auth-code]
----

Также можно использовать аннотацию `@Authenticated` для аутентификации всего метода бина, как выполняемого пользователем `system`. Например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/mbean/SettingsManagementFacade.java[tags=current-authentication;system-auth-ann]
----

[[authentication-events]]
== События аутентификации

Фреймворк Spring посылает определенные события приложения, связанные с аутентификацией.

TIP: Studio может помочь вам создать слушателей событий аутентификации. Нажмите *New (+) -> Event Listener* в окне инструментов *Jmix* и выберите *Authentication Event* в диалоговом окне.

Ниже приведен пример обработки событий аутентификации.

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/security/AuthenticationEventListener.java[tags=class]
----

<1> `InteractiveAuthenticationSuccessEvent` посылается, когда пользователь входит в систему через UI или REST API.
<2> `InteractiveAuthenticationSuccessEvent` содержит сущность пользователя.
<3> `AuthenticationSuccessEvent` отправляется при любой успешной аутентификации, включая <<system,системную>>.
<4> `AuthenticationSuccessEvent` содержит сущность пользователя.
<5> `AbstractAuthenticationFailureEvent` посылается, если попытка аутентификации не удалась, например, из-за ввода неверных учетных данных.
<6> `AbstractAuthenticationFailureEvent` содержит только имя пользователя, указанное при аутентификации.
<7> `LogoutSuccessEvent` посылается при выходе пользователя из системы.
<8> `LogoutSuccessEvent` содержит сущность пользователя.
